// standard library
array8u scratch[1];
array8u args[64];
array16 argv[8];
global argc;
global stdin;
global stdout;
function _kernel_puts(str);
function main();
function write(pipe, src, len);
function read(pipe, dest, len, maxtries);
function selfpid();
function strarr(array, string, delim);
function strlen(str);
function pipe_empty(pipe);
function _start() { // executable entrypoint
	stdin = selfpid() * 2;
	stdout = selfpid() * 2 + 1;
	$uf10(&args);
	//_kernel_puts(&args);
	argc = strarr(&argv, &args, " ");
	main();
	while ( !pipe_empty(stdout) ) {}
	$uf5();
}
function setuid(pid, id) { // setuid for 'pid' to 'id'
	$uf12(5, pid, id);
}
function getuid(pid) { // getuid for 'pid'
	return $uf12(4, pid);
}
function pipe_empty(pipe) { // check if 'pipe' is empty
	local ret;
	ret = $uf12(3, pipe);
	return ret;
}
function atoi(str) { // convert 'str' to number
   local i;
   local res; res = 0; 
    // Iterate through all characters of input string and
    // update result
    for (i = 0; $ptr8u[str, i]; i++)
        res = res*10 + $ptr8u[str, i] - 48;
  
    // return result.
    return res;

}
function strarr(array, str, delim) { // split 'str' by 'delim' into 'array', returns number of elements in 'array'
	local n, i, l;
	n = 0;
	l = 0;
	$ptr16[array, n] = str;
	for ( i = 0; $ptr8u[str, i]; i++ ) {
		if ( $ptr8u[str, i] == $ptr8u[delim, 0] ) {
			$ptr16[array, n] = str + l;
			$ptr8u[str, i] = 0;
			n++;
			l = i + 1;
		}
	}
	return n + 1;
}
function string(value) { // make a string
	return value;
}
function strcmp(str1, str2) { // compare strings
	local a, b, c, d;
	c = 1; a = 0;
	if ( strlen(str1) != strlen(str2) ) { return 1; }
	while ( a < strlen(str1) ) {
		if ( $ptr8u[str1, a] != $ptr8u[str2, a] ) { return 1; }
		a++;
	}
	return 0;
}
function exit() { // exit application
	$uf5();
}
function _kernel_putc(n) { // [syscall] put character to terminal
	$uf0(n);
}
function _kernel_getc() { // [syscall] get character from terminal
	return $uf1();
}

function fputc(pipe, char) { // write 'char' to 'pipe'
	scratch[0] = char;
	write(pipe, &scratch, 1);
	return 0;
}
function selfpid() { // get own process id
	return $uf7();
}
function fgetc(pipe) { // read character from 'pipe'
	local r; r = 0;
	while ( !r ) {
	r = $uf8(pipe, &scratch, 1);
	}
	return scratch[0];
}
function read(pipe, dest, len, maxtries) { // read from 'pipe' into 'dest' up to 'len' characters, retry 'maxtries' times
	local r;
	local tries;
	r = 0;
	tries = 0;
	while ( r == 0 && tries != maxtries ) {
	r = $uf8(pipe, dest, len);
	tries++;
	}
	return r;
}
function write(pipe, src, len) { // write data from 'src' 'len' characters into 'pipe'
	$uf9(pipe, src, len);
}
function fputs(pipe, str) { // write 'str' to 'pipe'
	write(pipe, str, strlen(str));
}
function fgets(pipe, str) { // read line from 'pipe' into 'str'
	local i, n;
	n = 1;
	for(i=0; n; i++) {
		
		$ptr8u[str, i] = fgetc(pipe);
		if ( $ptr8u[str, i] == 10 || $ptr8u[str, i] == 13 ) {
		$ptr8u[str,i] = 0;
		return i;
		}
	}
	
	$ptr8u[str, i] = 0;
	
	return i;
}
function _kernel_puts(str) { // [syscall] put string to terminal
	local i;
	for ( i = 0; $ptr8u[str, i]; i++ ) {
		$uf0($ptr8u[str, i]);
	}
}
function _kernel_gets(str) { // [syscall] get line from terminal
	local i;
	for(i=0; $ptr8u[str, i - 1] != 10; i++) {
		$ptr8u[str, i] = $uf1();
	}
	$ptr8u[str, i] = 0;
}
function strlen(str) { // get length of 'str'
	local i;
	for(i=0; $ptr8u[str, i]; i++ ) {
	}
	return i;
}
function reverse(s) { // reverse 's'
	local i, j, c, q;
	q = 1;
	j = strlen(s) - 1;
	while (q) {
		if ( i<j ) {
		c = $ptr8u[s, i];
		$ptr8u[s, i] = $ptr8u[s, j];
		$ptr8u[s, j] = c;
		i++;
		j--;
		} else {
		q = 0;
		}
	}
}
function itoa(n, str) { // convert number 'n' to string, store in 'str'
	local i;
	i = 0;
	while (n) {
		
		$ptr8u[str, i] = n % 10 + 48;
		i++;
		n = n / 10;
	}
	$ptr8u[str, i] = 0;
	reverse(str);
}
function fork() { // create new process
	
	local q;
	q = 0;
	q = $uf3();
	return q;
}
function wait(pid) { // wait for process 'pid' to die
	while (!$uf4(pid)) {}
}
function dead(pid) { // check if process 'pid' is dead
	return $uf4(pid);
}
function fwdio(pid) { // forward stdio to child 'pid'
	local cstdin, cstdout;
	cstdin = pid * 2;
	cstdout = pid * 2 + 1;
	if($uf8(cstdout, &scratch, 1)) {
		write(stdout, &scratch, 1);
		
	}
	if($uf8(stdin, &scratch, 1)) {
		write(cstdin, &scratch, 1);
	}
}
function strcpy(dest, src) { // standard strcpy implementation
	local i;
	for(i=0; $ptr8u[src, i]; i++) {
		$ptr8u[dest, i] = $ptr8u[src, i];
	}
	$ptr8u[dest, i] = 0;
}
function fputs_ex(pipe, s1, s2, s3, s4) { // join with spaces and print up to 4 strings
	fputs(pipe, s1);
	if(s2) { fputs(pipe, " "); fputs(pipe, s2); }
	if(s3) { fputs(pipe, " "); fputs(pipe, s3); }
	if(s4) { fputs(pipe, " "); fputs(pipe, s4); }
	
}
function exec(path, argstr) { // replace current running process with program at 'path'
	return $uf6(path, argstr);
}
function _kernel_info(dbuf) { // [syscall] get kernel information
	return $uf2(dbuf);
}
array8u sys_hostname[32];
function hostname() { // get system hostname
	$uf12(1, &sys_hostname);
	return &sys_hostname;
}
function sethostname(newhost) { // set system hostname
	$uf12(2, newhost);
}